---
title: "雑訳vignette: Pivoting (tidyr 1.0.0)"
author: ~
date: '2019-06-29'
lastmod: '2019-07-01'
slug: pivoting-tidyr-1-0-0
categories: [R]
tags: [tidyr]
output:
  blogdown::html_page:
    toc: true
aliases:
  - /2019/06/29/tidyr-1-0-0/
summary: |
  tiydr 1.0.0 で追加される pivot_longer() と pivot_wider() の使い方を紹介する vignette の雑な訳
---


<div id="TOC">
<ul>
<li><a href="#section">はじめに</a></li>
<li><a href="#longer">Longer</a><ul>
<li><a href="#pew">列の名前が文字列データに相当する場合</a></li>
<li><a href="#billboard">列の名前が数値データに相当する場合</a></li>
<li><a href="#section-1">列名に複数の変数がある場合</a></li>
<li><a href="#multiple-observations-per-row">一行に複数の観測値がある場合</a></li>
<li><a href="#section-2">列名が重複している場合</a></li>
</ul></li>
<li><a href="#wider">Wider</a><ul>
<li><a href="#capture-recapture-data">Capture-recapture data</a></li>
<li><a href="#aggregation">集約 (Aggregation)</a></li>
<li><a href="#section-3">複数の変数から複数の列名を生成する</a></li>
<li><a href="#tidy-census">整然とした国勢調査 (Tidy census)</a></li>
<li><a href="#section-4">連絡帳</a></li>
</ul></li>
<li><a href="#longer--wider-">Longer にしてから wider にする</a><ul>
<li><a href="#section-5">世界銀行</a></li>
<li><a href="#section-6">複数回答</a></li>
</ul></li>
<li><a href="#manual-specs">Manual specs</a><ul>
<li><a href="#longer-1">Longer</a></li>
<li><a href="#wider-1">Wider</a></li>
<li><a href="#by-hand">By hand</a></li>
<li><a href="#section-7">理論</a></li>
</ul></li>
</ul>
</div>

<p>tiydr 1.0.0 で追加される <code>pivot_longer()</code> と <code>pivot_wider()</code> の使い方を紹介する vignette を雑に訳した．まだ正式リリースしていないので，仕様もドキュメントも変わる可能性がある．これらの点に注意の上読んで欲しい．</p>
<p>実際，気付いたことをコメントした結果，変わってしまった仕様もある
(<a href="https://github.com/tidyverse/tidyr/issues/630">#630</a>)．他にも仕様やドキュメントに関する Issues 4件 と typo に対する PR を2件挙げてしまったので，<code>pivot_*</code> はまだまだこれから感が強い．</p>
<p>また，翻訳にはこなれていない部分や，適切な訳が分からず英語が残された部分もある．是非みなさんのコメントで訳を育てて欲しい．質問・コメントは <a href="https://twitter.com/Atsushi776/">@Atsushi776</a> (Twitter) まで．</p>
<p>個人的には， <a href="https://twitter.com/yutannihilation">@yutannihilation</a> 氏によるスライド「idyr 1.0.0?の新機能 pivot_*()」の説明が非常に分かりやすいのでまず，こちらを読んで，更に深いところを
vignette から学ぶことを薦める．<br />
<a href="https://speakerdeck.com/yutannihilation/tidyr-pivot" class="uri">https://speakerdeck.com/yutannihilation/tidyr-pivot</a></p>
<p>英語の記事では “Pivoting data from columns to rows (and back!) in the tidyverse” も評判が良い．私はまだ読んでいない．<br />
<a href="http://www.storybench.org/pivoting-data-from-columns-to-rows-and-back-in-the-tidyverse/" class="uri">http://www.storybench.org/pivoting-data-from-columns-to-rows-and-back-in-the-tidyverse/</a></p>
<p>vignette 原文: <a href="https://tidyr.tidyverse.org/dev/articles/pivot.html" class="uri">https://tidyr.tidyverse.org/dev/articles/pivot.html</a></p>
<div id="section" class="section level1">
<h1>はじめに</h1>
<p>この vignette では <code>pivot_longer()</code> と <code>pivot_wider()</code> の使い方を紹介する．これらの関数は <code>gather()</code> と <code>spread()</code> の機能を拡張し，他のパッケージから最新の機能を取り込むことを目指す．</p>
<p><code>spread()</code> と <code>gather()</code> には設計の基本的な部分に誤りがあった．これらの関数がどの方向に<em>データ</em>を広げたり集めたりするのか予想することも覚えることも難しかった．更に引数も非常に覚え辛く，開発者を含め多くの人が度々ドキュメントを参照する羽目になった．</p>
<p>そこで R における<em>データ</em>整形を発展させる2つの重要な新機能が，他のパッケージを参考に実装された．</p>
<ul>
<li><code>pivot_longer()</code> は型の異なる複数の値を記録した変数を扱うことができる．この機能は Matt Dowle と Arun Srinivasan による
<a href="https://github.com/Rdatatable/data.table/wiki">data.table</a> パッケージにおける改良型の <code>melt()</code> と <code>dcast()</code>
を参考にした．</li>
<li><code>pivot_longer()</code> と <code>pivot_wider()</code> はデータフレームに対し，列名に記録されたメタデータがどのようにデータ変数に変換されるべきか，あるいは逆変換されるべきかを的確に指定できる．この機能は John Mount と Nina Zumel による <a href="https://winvector.github.io/cdata/">cdata</a> パッケージから着想を得た．</li>
</ul>
<p>この vignette では，<code>pivot_longer()</code> と <code>pivot_wider()</code> の背景にある重要なアイディアを紹介する．これらのアイディアはこれまであなたが単純なものから複雑なものまで様々なデータ整形に取り組んできた中で用いてきたものだ．</p>
<p>始めに必要なパッケージを読み込む．実用的には <code>library(tidyverse)</code> で読み込むだろうが，<code>tidyverse</code> をパッケージの vignette で読み込むことはできない<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>．</p>
<pre class="r"><code>library(tidyr)
library(dplyr)
library(readr)</code></pre>
</div>
<div id="longer" class="section level1">
<h1>Longer</h1>
<p><code>pivot_longer()</code> はデータセットの行を増やし，列を減らすことで<em>長く</em> (longer) する．開発者は「長い形式 (long form)」という呼び方は合理的ではないと考えている．なぜなら，長さは相対的なもので例えばデータセットの A と B のどちらが長いといった言い方しかできないからだ．</p>
<p><code>pivot_longer()</code> は野生のデータセットに対してよく適用されるもので，分析を楽にするためというよりは，データの入力や比較を適切に行うために用いられる．次節からは， <code>pivot_longer()</code> の使い方を現実にありうる様々なデータセットを用いて紹介する．</p>
<div id="pew" class="section level2">
<h2>列の名前が文字列データに相当する場合</h2>
<p><code>relig_income</code> データセットは人々の宗教や年収について集計した結果をカウントデータとして記録している．</p>
<pre class="r"><code>relig_income
#&gt; # A tibble: 18 x 11
#&gt;    religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k`
#&gt;    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
#&gt;  1 Agnostic      27        34        60        81        76       137
#&gt;  2 Atheist       12        27        37        52        35        70
#&gt;  3 Buddhist      27        21        30        34        33        58
#&gt;  4 Catholic     418       617       732       670       638      1116
#&gt;  5 Don’t k…      15        14        15        11        10        35
#&gt;  6 Evangel…     575       869      1064       982       881      1486
#&gt;  7 Hindu          1         9         7         9        11        34
#&gt;  8 Histori…     228       244       236       238       197       223
#&gt;  9 Jehovah…      20        27        24        24        21        30
#&gt; 10 Jewish        19        19        25        25        30        95
#&gt; # … with 8 more rows, and 4 more variables: `$75-100k` &lt;dbl&gt;,
#&gt; #   `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, `Don&#39;t know/refused` &lt;dbl&gt;</code></pre>
<p>データセットには3つの変数が含まれる．</p>
<ul>
<li><code>religion</code> は行ごとに記録されている</li>
<li><code>income</code> は複数の列の名前として記録されている</li>
<li><code>count</code> はセルごとの値として記録されている</li>
</ul>
<p><code>pivot_longer()</code> を使って整形してみよう．</p>
<pre class="r"><code>relig_income %&gt;% 
  pivot_longer(-religion, names_to = &quot;income&quot;, values_to = &quot;count&quot;)
#&gt; Warning: `vec_type_common()` has been renamed to `vec_ptype_common()`.
#&gt; This warning is displayed once per session.
#&gt; # A tibble: 180 x 3
#&gt;    religion income             count
#&gt;    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;
#&gt;  1 Agnostic &lt;$10k                 27
#&gt;  2 Agnostic $10-20k               34
#&gt;  3 Agnostic $20-30k               60
#&gt;  4 Agnostic $30-40k               81
#&gt;  5 Agnostic $40-50k               76
#&gt;  6 Agnostic $50-75k              137
#&gt;  7 Agnostic $75-100k             122
#&gt;  8 Agnostic $100-150k            109
#&gt;  9 Agnostic &gt;150k                 84
#&gt; 10 Agnostic Don&#39;t know/refused    96
#&gt; # … with 170 more rows</code></pre>
<ul>
<li><p>第一引数は整形したいデータセットをとる (例えば <code>relig_income</code>)．</p></li>
<li><p>第二引数は整形対象となる列を指定する．今回は <code>religion</code> 以外の全ての列だ．</p></li>
<li><p><code>names_to</code> 引数には，列の名前として記録されたデータに変数としての名前を与える．今回なら <code>income</code> だ．</p></li>
<li><p><code>values_to</code> 引数にはセルの値として記録されているデータに変数としての名前を与える．今回なら <code>count</code> だ．</p></li>
</ul>
<p><code>names_to</code> と <code>values_to</code> のどちら<em>によって作られる列</em>も <code>relig_income</code> には含まれていないため，これらの引数には引用符で囲った文字列を指定する.</p>
</div>
<div id="billboard" class="section level2">
<h2>列の名前が数値データに相当する場合</h2>
<p><code>billboard</code> データセットは2000年のビルボードランキングを記録している．データの形式としては <code>relig_income</code> と似ているが，列の名前に記録されたデータは文字列ではなく数値そのものである．</p>
<pre class="r"><code>billboard
#&gt; # A tibble: 317 x 79
#&gt;    artist track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7
#&gt;    &lt;chr&gt;  &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 2 Pac  Baby… 2000-02-26      87    82    72    77    87    94    99
#&gt;  2 2Ge+h… The … 2000-09-02      91    87    92    NA    NA    NA    NA
#&gt;  3 3 Doo… Kryp… 2000-04-08      81    70    68    67    66    57    54
#&gt;  4 3 Doo… Loser 2000-10-21      76    76    72    69    67    65    55
#&gt;  5 504 B… Wobb… 2000-04-15      57    34    25    17    17    31    36
#&gt;  6 98^0   Give… 2000-08-19      51    39    34    26    26    19     2
#&gt;  7 A*Tee… Danc… 2000-07-08      97    97    96    95   100    NA    NA
#&gt;  8 Aaliy… I Do… 2000-01-29      84    62    51    41    38    35    35
#&gt;  9 Aaliy… Try … 2000-03-18      59    53    38    28    21    18    16
#&gt; 10 Adams… Open… 2000-08-26      76    76    74    69    68    67    61
#&gt; # … with 307 more rows, and 69 more variables: wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;,
#&gt; #   wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;,
#&gt; #   wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;,
#&gt; #   wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,
#&gt; #   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;,
#&gt; #   wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;,
#&gt; #   wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;,
#&gt; #   wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;,
#&gt; #   wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, wk47 &lt;dbl&gt;, wk48 &lt;dbl&gt;, wk49 &lt;dbl&gt;,
#&gt; #   wk50 &lt;dbl&gt;, wk51 &lt;dbl&gt;, wk52 &lt;dbl&gt;, wk53 &lt;dbl&gt;, wk54 &lt;dbl&gt;,
#&gt; #   wk55 &lt;dbl&gt;, wk56 &lt;dbl&gt;, wk57 &lt;dbl&gt;, wk58 &lt;dbl&gt;, wk59 &lt;dbl&gt;,
#&gt; #   wk60 &lt;dbl&gt;, wk61 &lt;dbl&gt;, wk62 &lt;dbl&gt;, wk63 &lt;dbl&gt;, wk64 &lt;dbl&gt;,
#&gt; #   wk65 &lt;dbl&gt;, wk66 &lt;lgl&gt;, wk67 &lt;lgl&gt;, wk68 &lt;lgl&gt;, wk69 &lt;lgl&gt;,
#&gt; #   wk70 &lt;lgl&gt;, wk71 &lt;lgl&gt;, wk72 &lt;lgl&gt;, wk73 &lt;lgl&gt;, wk74 &lt;lgl&gt;,
#&gt; #   wk75 &lt;lgl&gt;, wk76 &lt;lgl&gt;</code></pre>
<p>まずは <code>relig_income</code> dataset と同様に <code>billboard</code> データセットを整形してみよう．列名は <code>week</code> という変数に，セルの値は <code>rank</code> という変数にしよう．加えて，整形時に欠損値が出たらその行を消去するように <code>values_drop_na</code> を使おう．必ずしも全ての曲が76週間ランキング圏内にあるわけではないため，入力したデータを<em><code>values_drop_na</code>を使わず</em>整形すると，不必要に自明な <code>NA</code> が強制的に生じてしまう．</p>
<pre class="r"><code>billboard %&gt;% 
  pivot_longer(
    cols = starts_with(&quot;wk&quot;), 
    names_to = &quot;week&quot;, 
    values_to = &quot;rank&quot;,
    values_drop_na = TRUE
  )
#&gt; # A tibble: 5,307 x 5
#&gt;    artist  track                   date.entered week   rank
#&gt;    &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;
#&gt;  1 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk1      87
#&gt;  2 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk2      82
#&gt;  3 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk3      72
#&gt;  4 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk4      77
#&gt;  5 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk5      87
#&gt;  6 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk6      94
#&gt;  7 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   wk7      99
#&gt;  8 2Ge+her The Hardest Part Of ... 2000-09-02   wk1      91
#&gt;  9 2Ge+her The Hardest Part Of ... 2000-09-02   wk2      87
#&gt; 10 2Ge+her The Hardest Part Of ... 2000-09-02   wk3      92
#&gt; # … with 5,297 more rows</code></pre>
<p>各曲が何週間ランキング入りしていたか簡単に分かると嬉しいが，それには変数 <code>week</code> を整数に直す必要がある．これには2つの引数を追加で指定する必要がある．まず <code>names_prefix</code> 引数によって接頭辞の <code>wk</code> を消した上で，<code>names_ptypes</code> 引数によって <code>week</code> が整数であることを指定する<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>．</p>
<pre class="r"><code>billboard %&gt;% 
  pivot_longer(
    cols = starts_with(&quot;wk&quot;), 
    names_to = &quot;week&quot;, 
    names_prefix = &quot;wk&quot;,
    names_ptypes = list(week = integer()),
    values_to = &quot;rank&quot;,
    values_drop_na = TRUE
  )
#&gt; # A tibble: 5,307 x 5
#&gt;    artist  track                   date.entered  week  rank
#&gt;    &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;int&gt; &lt;dbl&gt;
#&gt;  1 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       1    87
#&gt;  2 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       2    82
#&gt;  3 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       3    72
#&gt;  4 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       4    77
#&gt;  5 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       5    87
#&gt;  6 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       6    94
#&gt;  7 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       7    99
#&gt;  8 2Ge+her The Hardest Part Of ... 2000-09-02       1    91
#&gt;  9 2Ge+her The Hardest Part Of ... 2000-09-02       2    87
#&gt; 10 2Ge+her The Hardest Part Of ... 2000-09-02       3    92
#&gt; # … with 5,297 more rows</code></pre>
</div>
<div id="section-1" class="section level2">
<h2>列名に複数の変数がある場合</h2>
<p>列名に複数の変数が詰めこまれていると，整形はより大変になる．例えば <code>who</code> データセットを見てみよう．</p>
<pre class="r"><code>who
#&gt; # A tibble: 7,240 x 60
#&gt;    country iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534
#&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;int&gt;       &lt;int&gt;        &lt;int&gt;        &lt;int&gt;
#&gt;  1 Afghan… AF    AFG    1980          NA           NA           NA
#&gt;  2 Afghan… AF    AFG    1981          NA           NA           NA
#&gt;  3 Afghan… AF    AFG    1982          NA           NA           NA
#&gt;  4 Afghan… AF    AFG    1983          NA           NA           NA
#&gt;  5 Afghan… AF    AFG    1984          NA           NA           NA
#&gt;  6 Afghan… AF    AFG    1985          NA           NA           NA
#&gt;  7 Afghan… AF    AFG    1986          NA           NA           NA
#&gt;  8 Afghan… AF    AFG    1987          NA           NA           NA
#&gt;  9 Afghan… AF    AFG    1988          NA           NA           NA
#&gt; 10 Afghan… AF    AFG    1989          NA           NA           NA
#&gt; # … with 7,230 more rows, and 53 more variables: new_sp_m3544 &lt;int&gt;,
#&gt; #   new_sp_m4554 &lt;int&gt;, new_sp_m5564 &lt;int&gt;, new_sp_m65 &lt;int&gt;,
#&gt; #   new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;,
#&gt; #   new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;,
#&gt; #   new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;,
#&gt; #   new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;,
#&gt; #   new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;,
#&gt; #   new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;,
#&gt; #   new_sn_f4554 &lt;int&gt;, new_sn_f5564 &lt;int&gt;, new_sn_f65 &lt;int&gt;,
#&gt; #   new_ep_m014 &lt;int&gt;, new_ep_m1524 &lt;int&gt;, new_ep_m2534 &lt;int&gt;,
#&gt; #   new_ep_m3544 &lt;int&gt;, new_ep_m4554 &lt;int&gt;, new_ep_m5564 &lt;int&gt;,
#&gt; #   new_ep_m65 &lt;int&gt;, new_ep_f014 &lt;int&gt;, new_ep_f1524 &lt;int&gt;,
#&gt; #   new_ep_f2534 &lt;int&gt;, new_ep_f3544 &lt;int&gt;, new_ep_f4554 &lt;int&gt;,
#&gt; #   new_ep_f5564 &lt;int&gt;, new_ep_f65 &lt;int&gt;, newrel_m014 &lt;int&gt;,
#&gt; #   newrel_m1524 &lt;int&gt;, newrel_m2534 &lt;int&gt;, newrel_m3544 &lt;int&gt;,
#&gt; #   newrel_m4554 &lt;int&gt;, newrel_m5564 &lt;int&gt;, newrel_m65 &lt;int&gt;,
#&gt; #   newrel_f014 &lt;int&gt;, newrel_f1524 &lt;int&gt;, newrel_f2534 &lt;int&gt;,
#&gt; #   newrel_f3544 &lt;int&gt;, newrel_f4554 &lt;int&gt;, newrel_f5564 &lt;int&gt;,
#&gt; #   newrel_f65 &lt;int&gt;</code></pre>
<p><code>country</code>, <code>iso2</code>, <code>iso3</code>, そして <code>year</code> は既に変数であり，そのままにしておけばいい．しかし <code>new_sp_m014</code> 列から <code>newrel_f65</code> 列までは4種類の変数がそれぞれの列名に含まれている．</p>
<ul>
<li><p>接頭辞の <code>new_</code>/<code>new</code> は新しくカウントした症状であることを示す．このデータセットは新しい例しか含まない．定数に相当するため今回は無視する．</p></li>
<li><p><code>sp</code>/<code>rel</code>/<code>sp</code>/<code>ep</code> は症状を診断した手法を示す．</p></li>
<li><p><code>m</code>/<code>f</code> は性別を示す．</p></li>
<li><p><code>014</code>/<code>1524</code>/<code>2535</code>/<code>3544</code>/<code>4554</code>/<code>65</code> は年齢層を示す<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>．</p></li>
</ul>
<p>今回は <code>names_pattern</code> を使うとしっくりくるだろう．
<code>names_pattern</code> は <code>extract</code> と似た操作性を持ち，
<code>()</code> を用いてグループ化した正規表現を指定することで，列名からグループとして各変数を取り出すことができる．</p>
<pre class="r"><code>who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), 
  names_pattern = &quot;new_?(.*)_(.)(.*)&quot;,
  values_to = &quot;count&quot;
)
#&gt; # A tibble: 405,440 x 8
#&gt;    country     iso2  iso3   year diagnosis gender age   count
#&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;
#&gt;  1 Afghanistan AF    AFG    1980 sp        m      014      NA
#&gt;  2 Afghanistan AF    AFG    1980 sp        m      1524     NA
#&gt;  3 Afghanistan AF    AFG    1980 sp        m      2534     NA
#&gt;  4 Afghanistan AF    AFG    1980 sp        m      3544     NA
#&gt;  5 Afghanistan AF    AFG    1980 sp        m      4554     NA
#&gt;  6 Afghanistan AF    AFG    1980 sp        m      5564     NA
#&gt;  7 Afghanistan AF    AFG    1980 sp        m      65       NA
#&gt;  8 Afghanistan AF    AFG    1980 sp        f      014      NA
#&gt;  9 Afghanistan AF    AFG    1980 sp        f      1524     NA
#&gt; 10 Afghanistan AF    AFG    1980 sp        f      2534     NA
#&gt; # … with 405,430 more rows</code></pre>
<p>更に一歩進んで <code>gender</code> と <code>age</code> 列に型を指定してみよう．この作法は値の分かっているカテゴリカルな変数の操作に優れている．</p>
<pre class="r"><code>who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), 
  names_pattern = &quot;new_?(.*)_(.)(.*)&quot;,
  names_ptypes = list(
    gender = factor(levels = c(&quot;f&quot;, &quot;m&quot;)),
    age = factor(
      levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), 
      ordered = TRUE
    )
  ),
  values_to = &quot;count&quot;
)
#&gt; # A tibble: 405,440 x 8
#&gt;    country     iso2  iso3   year diagnosis gender age   count
#&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;fct&gt;  &lt;ord&gt; &lt;int&gt;
#&gt;  1 Afghanistan AF    AFG    1980 sp        m      014      NA
#&gt;  2 Afghanistan AF    AFG    1980 sp        m      1524     NA
#&gt;  3 Afghanistan AF    AFG    1980 sp        m      2534     NA
#&gt;  4 Afghanistan AF    AFG    1980 sp        m      3544     NA
#&gt;  5 Afghanistan AF    AFG    1980 sp        m      4554     NA
#&gt;  6 Afghanistan AF    AFG    1980 sp        m      5564     NA
#&gt;  7 Afghanistan AF    AFG    1980 sp        m      65       NA
#&gt;  8 Afghanistan AF    AFG    1980 sp        f      014      NA
#&gt;  9 Afghanistan AF    AFG    1980 sp        f      1524     NA
#&gt; 10 Afghanistan AF    AFG    1980 sp        f      2534     NA
#&gt; # … with 405,430 more rows</code></pre>
</div>
<div id="multiple-observations-per-row" class="section level2">
<h2>一行に複数の観測値がある場合<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></h2>
<p>これまで見てきたデータフレームでは，整形時にセルの値が入る列 (value column) は1つだった．しかし多くの重要な整形問題では，セルの値が複数列に入ることがある．このような問題は，整形後のデータフレームに欲しい列名が，整形前のデータフレームの列名の一部になっていることで発覚する．この節では，そんなデータをどうやって整形するか見ていく．</p>
<p>以下の例の出典は
<a href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html">data.table vignette</a>
で，<code>tidyr</code> における解法を閃くきっかけとなった．</p>
<pre class="r"><code>family &lt;- tribble(
  ~family,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,
       1L, &quot;1998-11-26&quot;, &quot;2000-01-29&quot;,             1L,             2L,
       2L, &quot;1996-06-22&quot;,           NA,             2L,             NA,
       3L, &quot;2002-07-11&quot;, &quot;2004-04-05&quot;,             2L,             2L,
       4L, &quot;2004-10-10&quot;, &quot;2009-08-27&quot;,             1L,             1L,
       5L, &quot;2000-12-05&quot;, &quot;2005-02-28&quot;,             2L,             1L,
)
family &lt;- family %&gt;% mutate_at(vars(starts_with(&quot;dob&quot;)), parse_date)
family
#&gt; # A tibble: 5 x 5
#&gt;   family dob_child1 dob_child2 gender_child1 gender_child2
#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;             &lt;int&gt;         &lt;int&gt;
#&gt; 1      1 1998-11-26 2000-01-29             1             2
#&gt; 2      2 1996-06-22 NA                     2            NA
#&gt; 3      3 2002-07-11 2004-04-05             2             2
#&gt; 4      4 2004-10-10 2009-08-27             1             1
#&gt; 5      5 2000-12-05 2005-02-28             2             1</code></pre>
<p>ここには子供たちそれぞれの <code>gender</code> と <code>dob</code> (誕生日) の2種類の情報 (または値) が載っている．これらの情報を別々の列に分けなければならい．そこで <code>names_to</code> に複数の値を指定し，<code>names_sep</code> を使って変数の名前を切り分ける．ただし，特別な変数名である <code>.value</code> を使って <code>pivot_longer()</code> に列名の一部が整形後の value column になることを伝える．</p>
<pre class="r"><code>family %&gt;% 
  pivot_longer(
    -family, 
    names_to = c(&quot;.value&quot;, &quot;child&quot;),
    names_sep = &quot;_&quot;, 
    values_drop_na = TRUE
  )
#&gt; # A tibble: 9 x 4
#&gt;   family child  dob        gender
#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;      &lt;int&gt;
#&gt; 1      1 child1 1998-11-26      1
#&gt; 2      1 child2 2000-01-29      2
#&gt; 3      2 child1 1996-06-22      2
#&gt; 4      3 child1 2002-07-11      2
#&gt; 5      3 child2 2004-04-05      2
#&gt; 6      4 child1 2004-10-10      1
#&gt; 7      4 child2 2009-08-27      1
#&gt; 8      5 child1 2000-12-05      2
#&gt; 9      5 child2 2005-02-28      1</code></pre>
<p><code>values_drop_na = TRUE</code> を使うことで，入力データ上に観測値のない部分が出力において明示的に欠測値になってしまうことを防いでいる点に注意されたい．</p>
<p>この問題は base R に含まれている <code>anscombe</code> データセットにも存在する．</p>
<pre class="r"><code>anscombe
#&gt;    x1 x2 x3 x4    y1   y2    y3    y4
#&gt; 1  10 10 10  8  8.04 9.14  7.46  6.58
#&gt; 2   8  8  8  8  6.95 8.14  6.77  5.76
#&gt; 3  13 13 13  8  7.58 8.74 12.74  7.71
#&gt; 4   9  9  9  8  8.81 8.77  7.11  8.84
#&gt; 5  11 11 11  8  8.33 9.26  7.81  8.47
#&gt; 6  14 14 14  8  9.96 8.10  8.84  7.04
#&gt; 7   6  6  6  8  7.24 6.13  6.08  5.25
#&gt; 8   4  4  4 19  4.26 3.10  5.39 12.50
#&gt; 9  12 12 12  8 10.84 9.13  8.15  5.56
#&gt; 10  7  7  7  8  4.82 7.26  6.42  7.91
#&gt; 11  5  5  5  8  5.68 4.74  5.73  6.89</code></pre>
<p>このデータセットは Anscombe’s quartet を構成する4対の変数から成る (<code>x1</code> と <code>y1</code>，<code>x2</code> と <code>y2</code>，など)．これら4つのデータセットは内容が大きく異なるにも拘らず同じ要約統計量を示す(平均，標準偏差，相関など)．これを <code>set</code>, <code>x</code>, <code>y</code> から成るデータセットに整形してみる．</p>
<pre class="r"><code>anscombe %&gt;% 
  pivot_longer(everything(), 
    names_to = c(&quot;.value&quot;, &quot;set&quot;), 
    names_pattern = &quot;(.)(.)&quot;
  ) %&gt;% 
  arrange(set)
#&gt; # A tibble: 44 x 3
#&gt;    set       x     y
#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 1        10  8.04
#&gt;  2 1         8  6.95
#&gt;  3 1        13  7.58
#&gt;  4 1         9  8.81
#&gt;  5 1        11  8.33
#&gt;  6 1        14  9.96
#&gt;  7 1         6  7.24
#&gt;  8 1         4  4.26
#&gt;  9 1        12 10.8 
#&gt; 10 1         7  4.82
#&gt; # … with 34 more rows</code></pre>
<p>パネルデータでも似たような状況に遭遇する．例えば
<a href="http://github.com/leeper/rio/issues/193">Thomas Leeper</a>
によるデータセットを例にとってみよう．このデータの整形方法は <code>anscombe</code> に対して行ったものと同様だ．</p>
<pre class="r"><code>pnl &lt;- tibble(
  x = 1:4,
  a = c(1, 1,0, 0),
  b = c(0, 1, 1, 1),
  y1 = rnorm(4),
  y2 = rnorm(4),
  z1 = rep(3, 4),
  z2 = rep(-2, 4),
)

pnl %&gt;% 
  pivot_longer(
    -c(x, a, b), 
    names_to = c(&quot;.value&quot;, &quot;time&quot;), 
    names_pattern = &quot;(.)(.)&quot;
  )
#&gt; # A tibble: 8 x 6
#&gt;       x     a     b time       y     z
#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     1     0 1      0.148     3
#&gt; 2     1     1     0 2     -0.598    -2
#&gt; 3     2     1     1 1      1.25      3
#&gt; 4     2     1     1 2      0.171    -2
#&gt; 5     3     0     1 1     -0.858     3
#&gt; 6     3     0     1 2     -0.205    -2
#&gt; 7     4     0     1 1      1.39      3
#&gt; 8     4     0     1 2     -0.262    -2</code></pre>
</div>
<div id="section-2" class="section level2">
<h2>列名が重複している場合</h2>
<p>列名が重複したデータセットに遭遇することもあるだろう．一般的には R でこのようなデータセットを扱うのは難しい．なぜなら，名前で列を参照しようとすると，最初にマッチしたものしか参照できないからだ．列名の重複した tibble を作るには，そのようなデータセットの作成を防ぐ列名の修正機能を明示的に止めておく必要がある．</p>
<pre class="r"><code>df &lt;- tibble(x = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = &quot;minimal&quot;)
df
#&gt; # A tibble: 3 x 4
#&gt;       x     y     y     y
#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
#&gt; 1     1     4     5     7
#&gt; 2     2     5     6     8
#&gt; 3     3     6     7     9</code></pre>
<p>このようなデータを <code>pivot_longer()</code> で処理すると，出力には自動的に新しい列を追加される．</p>
<pre class="r"><code>df %&gt;% pivot_longer(-x, names_to = &quot;name&quot;, values_to = &quot;value&quot;)
#&gt; Warning: Duplicate column names detected, adding .copy variable
#&gt; # A tibble: 9 x 4
#&gt;       x name  .copy value
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt;
#&gt; 1     1 y         1     4
#&gt; 2     1 y         2     5
#&gt; 3     1 y         3     7
#&gt; 4     2 y         1     5
#&gt; 5     2 y         2     6
#&gt; 6     2 y         3     8
#&gt; 7     3 y         1     6
#&gt; 8     3 y         2     7
#&gt; 9     3 y         3     9</code></pre>
</div>
</div>
<div id="wider" class="section level1">
<h1>Wider</h1>
<p><code>pivot_wider()</code> は <code>pivot_longer()</code> の反対で，列数を増やして行数を減らすことで，データセットを<em>広く</em> (wider) する．<code>pivot_wider()</code> を使って整然データを作ることは珍しいが，<code>pivot_wider()</code> は発表用に要約した表を作る際やデータを他のツールに必要な形式に変換する際に役立つ．</p>
<div id="capture-recapture-data" class="section level2">
<h2>Capture-recapture data</h2>
<p><a href="https://fishsciences.github.io/post/visualizing-fish-encounter-histories/">Myfanwy Johnston</a> による
<code>fish_encounters</code> データセットは，自動観測機が川を下る魚を検出したかをまとめている．</p>
<pre class="r"><code>fish_encounters
#&gt; # A tibble: 114 x 3
#&gt;    fish  station  seen
#&gt;    &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;
#&gt;  1 4842  Release     1
#&gt;  2 4842  I80_1       1
#&gt;  3 4842  Lisbon      1
#&gt;  4 4842  Rstr        1
#&gt;  5 4842  Base_TD     1
#&gt;  6 4842  BCE         1
#&gt;  7 4842  BCW         1
#&gt;  8 4842  BCE2        1
#&gt;  9 4842  BCW2        1
#&gt; 10 4842  MAE         1
#&gt; # … with 104 more rows</code></pre>
<p>解析ツールの多くは，このデータが観測機ごとに列を成す形式に従っていることを求める．</p>
<pre class="r"><code>fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen)
#&gt; # A tibble: 19 x 12
#&gt;    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE
#&gt;    &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
#&gt;  1 4842        1     1      1     1       1     1     1     1     1     1
#&gt;  2 4843        1     1      1     1       1     1     1     1     1     1
#&gt;  3 4844        1     1      1     1       1     1     1     1     1     1
#&gt;  4 4845        1     1      1     1       1    NA    NA    NA    NA    NA
#&gt;  5 4847        1     1      1    NA      NA    NA    NA    NA    NA    NA
#&gt;  6 4848        1     1      1     1      NA    NA    NA    NA    NA    NA
#&gt;  7 4849        1     1     NA    NA      NA    NA    NA    NA    NA    NA
#&gt;  8 4850        1     1     NA     1       1     1     1    NA    NA    NA
#&gt;  9 4851        1     1     NA    NA      NA    NA    NA    NA    NA    NA
#&gt; 10 4854        1     1     NA    NA      NA    NA    NA    NA    NA    NA
#&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code></pre>
<p>このデータセットは，ある魚が観測機に観測された時だけ記録していて，観測されなかった時のことは記録していない (この種のデータでは一般的なことだ)．従って出力は <code>NA</code> で埋められる．しかしこの場合，欠測が魚を<code>見なかった</code>ことを意味すると分かっているので，<code>pivot_wider()</code> を使って欠測値を0で埋められる．</p>
<pre class="r"><code>fish_encounters %&gt;% pivot_wider(
  names_from = station, 
  values_from = seen,
  values_fill = list(seen = 0)
)
#&gt; # A tibble: 19 x 12
#&gt;    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE
#&gt;    &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
#&gt;  1 4842        1     1      1     1       1     1     1     1     1     1
#&gt;  2 4843        1     1      1     1       1     1     1     1     1     1
#&gt;  3 4844        1     1      1     1       1     1     1     1     1     1
#&gt;  4 4845        1     1      1     1       1     0     0     0     0     0
#&gt;  5 4847        1     1      1     0       0     0     0     0     0     0
#&gt;  6 4848        1     1      1     1       0     0     0     0     0     0
#&gt;  7 4849        1     1      0     0       0     0     0     0     0     0
#&gt;  8 4850        1     1      0     1       1     1     1     0     0     0
#&gt;  9 4851        1     1      0     0       0     0     0     0     0     0
#&gt; 10 4854        1     1      0     0       0     0     0     0     0     0
#&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code></pre>
</div>
<div id="aggregation" class="section level2">
<h2>集約 (Aggregation)</h2>
<p>また，<code>pivot_wider()</code> を使って単純な集約を行うこともできる．Base R に組込まれている <code>warpbreaks</code> データセットを例にとってみよう (出力の見栄えをよくするため tibble に変換しておく):</p>
<pre class="r"><code>warpbreaks &lt;- warpbreaks %&gt;% as_tibble() %&gt;% select(wool, tension, breaks)
warpbreaks
#&gt; # A tibble: 54 x 3
#&gt;    wool  tension breaks
#&gt;    &lt;fct&gt; &lt;fct&gt;    &lt;dbl&gt;
#&gt;  1 A     L           26
#&gt;  2 A     L           30
#&gt;  3 A     L           54
#&gt;  4 A     L           25
#&gt;  5 A     L           70
#&gt;  6 A     L           52
#&gt;  7 A     L           51
#&gt;  8 A     L           26
#&gt;  9 A     L           67
#&gt; 10 A     M           18
#&gt; # … with 44 more rows</code></pre>
<p>これは，<code>wool</code> (<code>A</code> と <code>B</code>) と <code>tension</code> (<code>L</code>, <code>M</code>, <code>H</code>) の全組み合わせに対し，
9回ずつ実験を繰り返した計画実験だ．</p>
<pre class="r"><code>warpbreaks %&gt;% count(wool, tension)
#&gt; # A tibble: 6 x 3
#&gt;   wool  tension     n
#&gt;   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;
#&gt; 1 A     L           9
#&gt; 2 A     M           9
#&gt; 3 A     H           9
#&gt; 4 B     L           9
#&gt; 5 B     M           9
#&gt; 6 B     H           9</code></pre>
<p><code>wool</code> (訳注: factor 型) の水準を列に展開するとどうなるだろうか．</p>
<pre class="r"><code>warpbreaks %&gt;% pivot_wider(names_from = wool, values_from = breaks)
#&gt; Warning: Values in `breaks` are not uniquely identified; output will contain list-cols.
#&gt; * Use `values_fn = list(breaks = list)` to suppress this warning.
#&gt; * Use `values_fn = list(breaks = length)` to identify where the duplicates arise
#&gt; * Use `values_fn = list(breaks = summary_fun)` to summarise duplicates
#&gt; # A tibble: 3 x 3
#&gt;   tension           A           B
#&gt;   &lt;fct&gt;   &lt;list&lt;dbl&gt;&gt; &lt;list&lt;dbl&gt;&gt;
#&gt; 1 L               [9]         [9]
#&gt; 2 M               [9]         [9]
#&gt; 3 H               [9]         [9]</code></pre>
<p>出力される各セルが入力された複数のセルに対応すると警告される．既定の挙動ではリストから成る列 (list-columns) を生成し，各要素は全ての個別の値を格納する．より便利な出力は要約統計量だろう．例えば <code>mean</code> によって，<code>wool</code> と <code>tention</code> の組み合わせごとに平均値を算出できる．</p>
<pre class="r"><code>warpbreaks %&gt;% 
  pivot_wider(
    names_from = wool, 
    values_from = breaks,
    values_fn = list(breaks = mean)
  )
#&gt; # A tibble: 3 x 3
#&gt;   tension     A     B
#&gt;   &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 L        44.6  28.2
#&gt; 2 M        24    28.8
#&gt; 3 H        24.6  18.8</code></pre>
<p>より複雑な要約は，整形前に行っておくことを薦めるが，単純なものは <code>pivot_wider()</code> で済ましてしまう方が便利なことも多い．</p>
</div>
<div id="section-3" class="section level2">
<h2>複数の変数から複数の列名を生成する</h2>
<p>あるデータセットが product，country，yearの組み合わせで構成されているとしよう
(例えば <a href="http://stackoverflow.com/questions/24929954" class="uri">http://stackoverflow.com/questions/24929954</a>)．整然とした形式では以下のようになる．</p>
<pre class="r"><code>production &lt;- expand_grid(
    product = c(&quot;A&quot;, &quot;B&quot;), 
    country = c(&quot;AI&quot;, &quot;EI&quot;), 
    year = 2000:2014
  ) %&gt;%
  filter((product == &quot;A&quot; &amp; country == &quot;AI&quot;) | product == &quot;B&quot;) %&gt;% 
  mutate(production = rnorm(nrow(.)))
production
#&gt; # A tibble: 45 x 4
#&gt;    product country  year production
#&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;
#&gt;  1 A       AI       2000     0.755 
#&gt;  2 A       AI       2001    -0.730 
#&gt;  3 A       AI       2002     0.0795
#&gt;  4 A       AI       2003    -2.40  
#&gt;  5 A       AI       2004    -1.20  
#&gt;  6 A       AI       2005     0.751 
#&gt;  7 A       AI       2006    -0.432 
#&gt;  8 A       AI       2007     0.523 
#&gt;  9 A       AI       2008    -0.522 
#&gt; 10 A       AI       2009    -1.12  
#&gt; # … with 35 more rows</code></pre>
<p>このデータを広げて，列ごとに異なる <code>product</code> と <code>country</code> の組み合わせを示すようにしよう．<code>names_from</code> に複数の変数を指定するのが鍵だ．</p>
<pre class="r"><code>production %&gt;% pivot_wider(
  names_from = c(product, country), 
  values_from = production
)
#&gt; # A tibble: 15 x 4
#&gt;     year    A_AI   B_AI   B_EI
#&gt;    &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
#&gt;  1  2000  0.755  -0.107  1.32 
#&gt;  2  2001 -0.730  -1.03   0.968
#&gt;  3  2002  0.0795 -0.279  1.85 
#&gt;  4  2003 -2.40    0.667  0.682
#&gt;  5  2004 -1.20    0.100  0.215
#&gt;  6  2005  0.751   1.77   1.57 
#&gt;  7  2006 -0.432  -0.914 -0.145
#&gt;  8  2007  0.523   0.363 -1.85 
#&gt;  9  2008 -0.522   0.337 -0.748
#&gt; 10  2009 -1.12   -0.336 -0.491
#&gt; # … with 5 more rows</code></pre>
</div>
<div id="tidy-census" class="section level2">
<h2>整然とした国勢調査 (Tidy census)</h2>
<p><code>us_rent_income</code> データセットは，2017年のアメリカ合衆国における年収と家賃の中央値を州ごとに集計している (the American Community Survey から <a href="https://walkerke.github.io/tidycensus">tidycensus</a> パッケージによって入手した).</p>
<pre class="r"><code>us_rent_income
#&gt; # A tibble: 104 x 5
#&gt;    GEOID NAME       variable estimate   moe
#&gt;    &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 01    Alabama    income      24476   136
#&gt;  2 01    Alabama    rent          747     3
#&gt;  3 02    Alaska     income      32940   508
#&gt;  4 02    Alaska     rent         1200    13
#&gt;  5 04    Arizona    income      27517   148
#&gt;  6 04    Arizona    rent          972     4
#&gt;  7 05    Arkansas   income      23789   165
#&gt;  8 05    Arkansas   rent          709     5
#&gt;  9 06    California income      29454   109
#&gt; 10 06    California rent         1358     3
#&gt; # … with 94 more rows</code></pre>
<p><code>estimate</code> と <code>moe</code> は両方とも values columns であるため，<code>values_from</code> に指定する．</p>
<pre class="r"><code>us_rent_income %&gt;% 
  pivot_wider(names_from = variable, values_from = c(estimate, moe))
#&gt; # A tibble: 52 x 6
#&gt;    GEOID NAME             estimate_income estimate_rent moe_income moe_rent
#&gt;    &lt;chr&gt; &lt;chr&gt;                      &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama                    24476           747        136        3
#&gt;  2 02    Alaska                     32940          1200        508       13
#&gt;  3 04    Arizona                    27517           972        148        4
#&gt;  4 05    Arkansas                   23789           709        165        5
#&gt;  5 06    California                 29454          1358        109        3
#&gt;  6 08    Colorado                   32401          1125        109        5
#&gt;  7 09    Connecticut                35326          1123        195        5
#&gt;  8 10    Delaware                   31560          1076        247       10
#&gt;  9 11    District of Col…           43198          1424        681       17
#&gt; 10 12    Florida                    25952          1077         70        3
#&gt; # … with 42 more rows</code></pre>
<p>出力される列には変数名が自動的に追記されることに注意されたい．</p>
</div>
<div id="section-4" class="section level2">
<h2>連絡帳</h2>
<p>最後に取り組む問題は
<a href="https://github.com/jienagu/tidyverse_examples/blob/master/example_long_wide.R">Jiena Gu</a>
に影響されたものだ．以下のようにウェブサイトからコピー&amp;ペーストした連絡帳があるとしよう．</p>
<pre class="r"><code>contacts &lt;- tribble(
  ~field, ~value,
  &quot;name&quot;, &quot;Jiena McLellan&quot;,
  &quot;company&quot;, &quot;Toyota&quot;, 
  &quot;name&quot;, &quot;John Smith&quot;, 
  &quot;company&quot;, &quot;google&quot;, 
  &quot;email&quot;, &quot;john@google.com&quot;,
  &quot;name&quot;, &quot;Huxley Ratcliffe&quot;
)</code></pre>
<p>このデータセットではどの値が同じ組になるか分からないことが課題だ．全ての連絡先が名前 (name) から始まっていることに気付けば，この課題を解決できる．<code>field</code> 列に “name” が現れる度に固有の id を割り当てよう．</p>
<pre class="r"><code>contacts &lt;- contacts %&gt;% 
  mutate(
    person_id = cumsum(field == &quot;name&quot;)
  )
contacts
#&gt; # A tibble: 6 x 3
#&gt;   field   value            person_id
#&gt;   &lt;chr&gt;   &lt;chr&gt;                &lt;int&gt;
#&gt; 1 name    Jiena McLellan           1
#&gt; 2 company Toyota                   1
#&gt; 3 name    John Smith               2
#&gt; 4 company google                   2
#&gt; 5 email   john@google.com          2
#&gt; 6 name    Huxley Ratcliffe         3</code></pre>
<p>これで各人に対し，固有な識別子が割り当てられたので，<code>field</code> と <code>value</code> を列に展開できる．</p>
<pre class="r"><code>contacts %&gt;% 
  pivot_wider(names_from = field, values_from = value)
#&gt; # A tibble: 3 x 4
#&gt;   person_id name             company email          
#&gt;       &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;          
#&gt; 1         1 Jiena McLellan   Toyota  &lt;NA&gt;           
#&gt; 2         2 John Smith       google  john@google.com
#&gt; 3         3 Huxley Ratcliffe &lt;NA&gt;    &lt;NA&gt;</code></pre>
</div>
</div>
<div id="longer--wider-" class="section level1">
<h1>Longer にしてから wider にする</h1>
<p>一方向に pivot するだけでは問題が解決しないことがある．本節では<code>pivot_longer()</code> と <code>pivot_wider()</code> を組み合わせて複雑な問題を解決する例を紹介する．</p>
<div id="section-5" class="section level2">
<h2>世界銀行</h2>
<p><code>world_bank_pop</code> は世界銀行による2000年から2018年までの各国の人口に関するデータが記録されている．</p>
<pre class="r"><code>world_bank_pop
#&gt; # A tibble: 1,056 x 20
#&gt;    country indicator `2000` `2001` `2002` `2003`  `2004`  `2005`   `2006`
#&gt;    &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 ABW     SP.URB.T… 4.24e4 4.30e4 4.37e4 4.42e4 4.47e+4 4.49e+4  4.49e+4
#&gt;  2 ABW     SP.URB.G… 1.18e0 1.41e0 1.43e0 1.31e0 9.51e-1 4.91e-1 -1.78e-2
#&gt;  3 ABW     SP.POP.T… 9.09e4 9.29e4 9.50e4 9.70e4 9.87e+4 1.00e+5  1.01e+5
#&gt;  4 ABW     SP.POP.G… 2.06e0 2.23e0 2.23e0 2.11e0 1.76e+0 1.30e+0  7.98e-1
#&gt;  5 AFG     SP.URB.T… 4.44e6 4.65e6 4.89e6 5.16e6 5.43e+6 5.69e+6  5.93e+6
#&gt;  6 AFG     SP.URB.G… 3.91e0 4.66e0 5.13e0 5.23e0 5.12e+0 4.77e+0  4.12e+0
#&gt;  7 AFG     SP.POP.T… 2.01e7 2.10e7 2.20e7 2.31e7 2.41e+7 2.51e+7  2.59e+7
#&gt;  8 AFG     SP.POP.G… 3.49e0 4.25e0 4.72e0 4.82e0 4.47e+0 3.87e+0  3.23e+0
#&gt;  9 AGO     SP.URB.T… 8.23e6 8.71e6 9.22e6 9.77e6 1.03e+7 1.09e+7  1.15e+7
#&gt; 10 AGO     SP.URB.G… 5.44e0 5.59e0 5.70e0 5.76e0 5.75e+0 5.69e+0  4.92e+0
#&gt; # … with 1,046 more rows, and 11 more variables: `2007` &lt;dbl&gt;,
#&gt; #   `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;,
#&gt; #   `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;</code></pre>
<p>このデータセットを，それぞれの変数が一つの列に納ままるように整形しよう．この段階ではどのような手順を踏めばいいか分からないが，まず最も明らかな問題である，複数列にまたがる <code>yaer</code> を修正しよう．</p>
<pre class="r"><code>pop2 &lt;- world_bank_pop %&gt;% 
  pivot_longer(`2000`:`2017`, names_to = &quot;year&quot;, values_to = &quot;value&quot;)
pop2
#&gt; # A tibble: 19,008 x 4
#&gt;    country indicator   year  value
#&gt;    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
#&gt;  1 ABW     SP.URB.TOTL 2000  42444
#&gt;  2 ABW     SP.URB.TOTL 2001  43048
#&gt;  3 ABW     SP.URB.TOTL 2002  43670
#&gt;  4 ABW     SP.URB.TOTL 2003  44246
#&gt;  5 ABW     SP.URB.TOTL 2004  44669
#&gt;  6 ABW     SP.URB.TOTL 2005  44889
#&gt;  7 ABW     SP.URB.TOTL 2006  44881
#&gt;  8 ABW     SP.URB.TOTL 2007  44686
#&gt;  9 ABW     SP.URB.TOTL 2008  44375
#&gt; 10 ABW     SP.URB.TOTL 2009  44052
#&gt; # … with 18,998 more rows</code></pre>
<p>次に， <code>indicator</code> 列を見てみよう．</p>
<pre class="r"><code>pop2 %&gt;% count(indicator)
#&gt; # A tibble: 4 x 2
#&gt;   indicator       n
#&gt;   &lt;chr&gt;       &lt;int&gt;
#&gt; 1 SP.POP.GROW  4752
#&gt; 2 SP.POP.TOTL  4752
#&gt; 3 SP.URB.GROW  4752
#&gt; 4 SP.URB.TOTL  4752</code></pre>
<p><code>SP.POP.GROW</code> は人口増加を, <code>SP.POP.TOTL</code> は総人口を, そして <code>SP.URB.*</code> は都会における人口増加と総人口を示す．これらを観測値が全域から得たものか都会から得たものか示す <code>area</code> 列と，観測値が総人口と人口増加のどちらを記録しているか示す <code>variable</code> 列の2列に分けよう．</p>
<pre class="r"><code>pop3 &lt;- pop2 %&gt;% 
  separate(indicator, c(NA, &quot;area&quot;, &quot;variable&quot;))
pop3
#&gt; # A tibble: 19,008 x 5
#&gt;    country area  variable year  value
#&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
#&gt;  1 ABW     URB   TOTL     2000  42444
#&gt;  2 ABW     URB   TOTL     2001  43048
#&gt;  3 ABW     URB   TOTL     2002  43670
#&gt;  4 ABW     URB   TOTL     2003  44246
#&gt;  5 ABW     URB   TOTL     2004  44669
#&gt;  6 ABW     URB   TOTL     2005  44889
#&gt;  7 ABW     URB   TOTL     2006  44881
#&gt;  8 ABW     URB   TOTL     2007  44686
#&gt;  9 ABW     URB   TOTL     2008  44375
#&gt; 10 ABW     URB   TOTL     2009  44052
#&gt; # … with 18,998 more rows</code></pre>
<p>最後に <code>variable</code> 列と <code>value</code> 列を展開し，<code>TOTL</code> 列と <code>GROW</code> 列にしよう．</p>
<pre class="r"><code>pop3 %&gt;% 
  pivot_wider(names_from = variable, values_from = value)
#&gt; # A tibble: 9,504 x 5
#&gt;    country area  year   TOTL    GROW
#&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 ABW     URB   2000  42444  1.18  
#&gt;  2 ABW     URB   2001  43048  1.41  
#&gt;  3 ABW     URB   2002  43670  1.43  
#&gt;  4 ABW     URB   2003  44246  1.31  
#&gt;  5 ABW     URB   2004  44669  0.951 
#&gt;  6 ABW     URB   2005  44889  0.491 
#&gt;  7 ABW     URB   2006  44881 -0.0178
#&gt;  8 ABW     URB   2007  44686 -0.435 
#&gt;  9 ABW     URB   2008  44375 -0.698 
#&gt; 10 ABW     URB   2009  44052 -0.731 
#&gt; # … with 9,494 more rows</code></pre>
</div>
<div id="section-6" class="section level2">
<h2>複数回答</h2>
<p><a href="https://github.com/MaximeWack">Maxime Wack</a> による提案を受けて <a href="https://github.com/tidyverse/tidyr/issues/384" class="uri">https://github.com/tidyverse/tidyr/issues/384</a>)，よくある複数回答データをどのように扱えばいいかを最後の例としよう．複数回答データは以下のような形式であることが多い．</p>
<pre class="r"><code>multi &lt;- tribble(
  ~id, ~choice1, ~choice2, ~choice3,
  1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;,
  2, &quot;C&quot;, &quot;B&quot;,  NA,
  3, &quot;D&quot;,  NA,  NA,
  4, &quot;B&quot;, &quot;D&quot;,  NA
)</code></pre>
<p>しかし，実際の順番は重要ではなく，id ごとの解答内容を示したいとしよう<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>．望んだ形式への変換は2つの操作で完了する．まず，データを longer 形式にし，自明な <code>NA</code> を消去し，選択肢から回答を得られたかを示す列を追加する．</p>
<pre class="r"><code>multi2 &lt;- multi %&gt;% 
  pivot_longer(-id, values_drop_na = TRUE) %&gt;% 
  mutate(checked = TRUE)
multi2
#&gt; # A tibble: 8 x 4
#&gt;      id name    value checked
#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;lgl&gt;  
#&gt; 1     1 choice1 A     TRUE   
#&gt; 2     1 choice2 B     TRUE   
#&gt; 3     1 choice3 C     TRUE   
#&gt; 4     2 choice1 C     TRUE   
#&gt; 5     2 choice2 B     TRUE   
#&gt; 6     3 choice1 D     TRUE   
#&gt; 7     4 choice1 B     TRUE   
#&gt; 8     4 choice2 D     TRUE</code></pre>
<p>次にデータを <code>wider</code> 型にし，無回答部分を <code>FALSE</code> で埋める．</p>
<pre class="r"><code>multi2 %&gt;% 
  pivot_wider(
    id_cols = id,
    names_from = value, 
    values_from = checked, 
    values_fill = list(checked = FALSE)
  )
#&gt; # A tibble: 4 x 5
#&gt;      id A     B     C     D    
#&gt;   &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;
#&gt; 1     1 TRUE  TRUE  TRUE  FALSE
#&gt; 2     2 FALSE TRUE  TRUE  FALSE
#&gt; 3     3 FALSE FALSE FALSE TRUE 
#&gt; 4     4 FALSE TRUE  FALSE TRUE</code></pre>
</div>
</div>
<div id="manual-specs" class="section level1">
<h1>Manual specs</h1>
<p><code>pivot_longer()</code> と <code>pivot_wider()</code> の引数は，様々なデータセットの整形を可能とする．しかし人々がデータ構造に対して発揮する想像力は無尽蔵にも見えるので，一見 <code>pivot_longer()</code> と <code>pivot_wider()</code> でもどうしようもない問題に遭遇することもありえる．より柔軟な整形を行うためには，仕様となるデータフレームを作り，厳格に列名ごとに格納されるデータがどのようにあるべきか，あるいはある種のデータが格納される列の名前がどのようにあるべきか，決めておける．本節では，どのようにデータ構造の仕様を定めればよいか紹介し，
<code>pivot_longer()</code> と <code>pivot_wider()</code> が不十分な場合にその仕様をどう示せばいいのかを紹介する．</p>
<div id="longer-1" class="section level2">
<h2>Longer</h2>
<p>仕様の策定方法を学ぶにあたって， <code>relig_income</code> データセットを用いたもっとも単純な整形をやり直してみよう．今回は整形に2段階の手順を踏む．まず，仕様となるオブジェクトを <code>pivot_longer_spec()</code> を用いて作り，整形時に仕様を利用する．</p>
<pre class="r"><code>spec &lt;- relig_income %&gt;% pivot_longer_spec(
  cols = -religion, 
  names_to = &quot;income&quot;,
  values_to = &quot;count&quot;
)
relig_income %&gt;% pivot_longer(spec = spec)
#&gt; # A tibble: 180 x 3
#&gt;    religion income             count
#&gt;    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;
#&gt;  1 Agnostic &lt;$10k                 27
#&gt;  2 Agnostic $10-20k               34
#&gt;  3 Agnostic $20-30k               60
#&gt;  4 Agnostic $30-40k               81
#&gt;  5 Agnostic $40-50k               76
#&gt;  6 Agnostic $50-75k              137
#&gt;  7 Agnostic $75-100k             122
#&gt;  8 Agnostic $100-150k            109
#&gt;  9 Agnostic &gt;150k                 84
#&gt; 10 Agnostic Don&#39;t know/refused    96
#&gt; # … with 170 more rows</code></pre>
<p>(コードは増えたが結果は以前と同じだ．この場合， <code>spec</code> を定める必要はないが，用例を示す単純な例として紹介した．)</p>
<p><code>spec</code> の中身はデータフレームで，各行は元のデータフレームの各列に対応しており<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>，
<code>.</code> から始まる2つの特別な列を持つ．</p>
<ul>
<li><code>.name</code> は列名を示す．</li>
<li><code>.value</code> はセルの移動先となる列の名前を示す．</li>
</ul>
<pre class="r"><code>spec
#&gt; # A tibble: 10 x 3
#&gt;    .name              .value income            
#&gt;    &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;             
#&gt;  1 &lt;$10k              count  &lt;$10k             
#&gt;  2 $10-20k            count  $10-20k           
#&gt;  3 $20-30k            count  $20-30k           
#&gt;  4 $30-40k            count  $30-40k           
#&gt;  5 $40-50k            count  $40-50k           
#&gt;  6 $50-75k            count  $50-75k           
#&gt;  7 $75-100k           count  $75-100k          
#&gt;  8 $100-150k          count  $100-150k         
#&gt;  9 &gt;150k              count  &gt;150k             
#&gt; 10 Don&#39;t know/refused count  Don&#39;t know/refused</code></pre>
</div>
<div id="wider-1" class="section level2">
<h2>Wider</h2>
<p>以下では <code>us_rent_income</code> を <code>pivot_wider()</code> によって広げている．良い結果が得られているが改善の余地があるだろう．</p>
<pre class="r"><code>us_rent_income %&gt;% 
  pivot_wider(names_from = variable, values_from = c(estimate, moe))
#&gt; # A tibble: 52 x 6
#&gt;    GEOID NAME             estimate_income estimate_rent moe_income moe_rent
#&gt;    &lt;chr&gt; &lt;chr&gt;                      &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama                    24476           747        136        3
#&gt;  2 02    Alaska                     32940          1200        508       13
#&gt;  3 04    Arizona                    27517           972        148        4
#&gt;  4 05    Arkansas                   23789           709        165        5
#&gt;  5 06    California                 29454          1358        109        3
#&gt;  6 08    Colorado                   32401          1125        109        5
#&gt;  7 09    Connecticut                35326          1123        195        5
#&gt;  8 10    Delaware                   31560          1076        247       10
#&gt;  9 11    District of Col…           43198          1424        681       17
#&gt; 10 12    Florida                    25952          1077         70        3
#&gt; # … with 42 more rows</code></pre>
<p>手製の仕様 (manual spec) を使って列名を <code>rent</code>，<code>rent_moe</code>，<code>income</code>，<code>income_moe</code> に改善しよう．現在の仕様は以下の通りだ．</p>
<pre class="r"><code>us_rent_income %&gt;% 
  pivot_wider_spec(names_from = variable, values_from = c(estimate, moe))
#&gt; # A tibble: 4 x 3
#&gt;   .name           .value   variable
#&gt;   &lt;chr&gt;           &lt;chr&gt;    &lt;chr&gt;   
#&gt; 1 estimate_income estimate income  
#&gt; 2 estimate_rent   estimate rent    
#&gt; 3 moe_income      moe      income  
#&gt; 4 moe_rent        moe      rent</code></pre>
<p>まず，<code>.value</code> と <code>variable</code> の組み合わせを全て作り，注意深く列名を決める<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>．</p>
<pre class="r"><code>spec &lt;- us_rent_income %&gt;% 
  expand(variable, .value = c(&quot;estimate&quot;, &quot;moe&quot;)) %&gt;% 
  mutate(
    .name = paste0(variable, ifelse(.value == &quot;moe&quot;, &quot;_moe&quot;, &quot;&quot;))
  )
spec
#&gt; # A tibble: 4 x 3
#&gt;   variable .value   .name     
#&gt;   &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;     
#&gt; 1 income   estimate income    
#&gt; 2 income   moe      income_moe
#&gt; 3 rent     estimate rent      
#&gt; 4 rent     moe      rent_moe</code></pre>
<p>この仕様を <code>pivot_wider()</code> に与えると，望み通りのデータフレームが得られる．</p>
<pre class="r"><code>us_rent_income %&gt;% pivot_wider(spec = spec)
#&gt; # A tibble: 52 x 6
#&gt;    GEOID NAME                 income income_moe  rent rent_moe
#&gt;    &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama               24476        136   747        3
#&gt;  2 02    Alaska                32940        508  1200       13
#&gt;  3 04    Arizona               27517        148   972        4
#&gt;  4 05    Arkansas              23789        165   709        5
#&gt;  5 06    California            29454        109  1358        3
#&gt;  6 08    Colorado              32401        109  1125        5
#&gt;  7 09    Connecticut           35326        195  1123        5
#&gt;  8 10    Delaware              31560        247  1076       10
#&gt;  9 11    District of Columbia  43198        681  1424       17
#&gt; 10 12    Florida               25952         70  1077        3
#&gt; # … with 42 more rows</code></pre>
</div>
<div id="by-hand" class="section level2">
<h2>By hand</h2>
<p>時には仕様を算出させるのが不可能な場合や不都合な場合があり，自前 (“by hand”) で仕様を定めた方が都合がいいこともある．<code>construction</code> データを例に見てみよう．このデータは下記 URL の表5 “completions” を少し改造したものだ <a href="https://www.census.gov/construction/nrc/index.html" class="uri">https://www.census.gov/construction/nrc/index.html</a>．</p>
<pre class="r"><code>construction
#&gt; # A tibble: 9 x 9
#&gt;    Year Month `1 unit` `2 to 4 units` `5 units or mor… Northeast Midwest
#&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;lgl&gt;                     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1  2018 Janu…      859 NA                          348       114     169
#&gt; 2  2018 Febr…      882 NA                          400       138     160
#&gt; 3  2018 March      862 NA                          356       150     154
#&gt; 4  2018 April      797 NA                          447       144     196
#&gt; 5  2018 May        875 NA                          364        90     169
#&gt; 6  2018 June       867 NA                          342        76     170
#&gt; 7  2018 July       829 NA                          360       108     183
#&gt; 8  2018 Augu…      939 NA                          286        90     205
#&gt; 9  2018 Sept…      835 NA                          304       117     175
#&gt; # … with 2 more variables: South &lt;dbl&gt;, West &lt;dbl&gt;</code></pre>
<p>このようなデータは政府機関が発行するものにありがちで，列名が色々な変数に属している．今回の場合は色々なユニットごと (1, 2–4, 5+) に要約した列と，国内の地方ごと (NE, NW, midwest, S, W) の要約した列がある．このようなデータを整形する際の仕様は tibble を使って簡単に記述できる．</p>
<pre class="r"><code>spec &lt;- tribble(
  ~.name,            ~.value, ~units,  ~region,     
  &quot;1 unit&quot;,          &quot;n&quot;,     &quot;1&quot;,     NA,          
  &quot;2 to 4 units&quot;,    &quot;n&quot;,     &quot;2-4&quot;,   NA,          
  &quot;5 units or more&quot;, &quot;n&quot;,     &quot;5+&quot;,    NA,          
  &quot;Northeast&quot;,       &quot;n&quot;,     NA,      &quot;Northeast&quot;, 
  &quot;Midwest&quot;,         &quot;n&quot;,     NA,      &quot;Midwest&quot;,   
  &quot;South&quot;,           &quot;n&quot;,     NA,      &quot;South&quot;,     
  &quot;West&quot;,            &quot;n&quot;,     NA,      &quot;West&quot;,      
)</code></pre>
<p>この仕様を用いると，以下のような longer な形式になる．</p>
<pre class="r"><code>construction %&gt;% pivot_longer(spec = spec)
#&gt; # A tibble: 63 x 5
#&gt;     Year Month    units region        n
#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;
#&gt;  1  2018 January  1     &lt;NA&gt;        859
#&gt;  2  2018 January  2-4   &lt;NA&gt;         NA
#&gt;  3  2018 January  5+    &lt;NA&gt;        348
#&gt;  4  2018 January  &lt;NA&gt;  Northeast   114
#&gt;  5  2018 January  &lt;NA&gt;  Midwest     169
#&gt;  6  2018 January  &lt;NA&gt;  South       596
#&gt;  7  2018 January  &lt;NA&gt;  West        339
#&gt;  8  2018 February 1     &lt;NA&gt;        882
#&gt;  9  2018 February 2-4   &lt;NA&gt;         NA
#&gt; 10  2018 February 5+    &lt;NA&gt;        400
#&gt; # … with 53 more rows</code></pre>
<p><code>units</code> 変数と <code>region</code> 変数には重複するとこがないことに注意されたい．今回の場合はデータを独立した二つの表に分けるのが最も自然だ．</p>
</div>
<div id="section-7" class="section level2">
<h2>理論</h2>
<p><code>spec</code> の良いところは，<code>pivot_longer()</code> と <code>pivot_wider()</code> に同じものを与えられることだ．これにより，二つの操作の対称性が明確になる．</p>
<pre class="r"><code>construction %&gt;% 
  pivot_longer(spec = spec) %&gt;% 
  pivot_wider(spec = spec)
#&gt; # A tibble: 9 x 9
#&gt;    Year Month `1 unit` `2 to 4 units` `5 units or mor… Northeast Midwest
#&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;          &lt;dbl&gt;            &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1  2018 Janu…      859             NA              348       114     169
#&gt; 2  2018 Febr…      882             NA              400       138     160
#&gt; 3  2018 March      862             NA              356       150     154
#&gt; 4  2018 April      797             NA              447       144     196
#&gt; 5  2018 May        875             NA              364        90     169
#&gt; 6  2018 June       867             NA              342        76     170
#&gt; 7  2018 July       829             NA              360       108     183
#&gt; 8  2018 Augu…      939             NA              286        90     205
#&gt; 9  2018 Sept…      835             NA              304       117     175
#&gt; # … with 2 more variables: South &lt;dbl&gt;, West &lt;dbl&gt;</code></pre>
<p>整形の仕様を定めることで，<code>pivot_longer(df, spec = spec)</code> がどのように <code>df</code> を整形するかより明瞭で厳密にできる．出力結果は <code>nrow(df) * nrow(spec)</code> に相当する行数と, <code>ncol(df) - nrow(spec) + ncol(spec) - 2</code> に相当する列数を持つ．</p>
<!-- Atusy による追加のリンク -->
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>訳注: <code>tidyverse</code> を vignette で利用すると，最低でも <code>Suggests</code> に <code>tidyverse</code>
を加えなければならない．しかし <code>tidyverse</code> は多くのパッケージを纏めたメタパッケージなので，不要なパッケージにも依存することになり，パッケージがいたずらに肥大化するのでよくない．
(参考: “The tidyverse is for EDA, not packages”
<a href="https://www.tidyverse.org/articles/2018/06/tidyverse-not-for-packages/" class="uri">https://www.tidyverse.org/articles/2018/06/tidyverse-not-for-packages/</a>)<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>訳注: ptype は prototype の略称．本来のタイプくらいの意味合いだろうか． <a href="https://twitter.com/yutannihilation">@yutannihilation</a> 氏によるスライドも参考にして欲しい
(<a href="https://speakerdeck.com/yutannihilation/tidyr-pivot?slide=51" class="uri">https://speakerdeck.com/yutannihilation/tidyr-pivot?slide=51</a>)．<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>訳注: <code>014</code>なら0歳から14歳，<code>1524</code>なら15歳から24歳であることを示す．<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>訳注: 直感的な見出しではないと思う．かと言って良い対案も思いついていない．暫定版は整形対象となる列の値に複数種の変数がある場合，くらいだろうか．<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>訳注: 原文は “you’d prefer to have the individual questions in the columns.” であるが，“questions” ではなく “answers” が正しい気がする．<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>訳注: 原文では元のデータフレームとまで書いていないが伝わらないと思ったので追記した．
<code>pivot_wider_spec()</code> の場合は <code>.name</code> 列の値が出力のデータフレームの各列に対応するので注意．<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>訳注: <code>expand %&gt;% mutate</code> よりも <code>pivot_wider_spec %&gt;% mutate</code> の方が，行や列の順序が <code>pivot_wider_spec</code> の結果と整合的で比べやすく，安全だと思う (<a href="https://github.com/tidyverse/tidyr/issues/666">#666</a>)．</p>
<pre class="r"><code>us_rent_income %&gt;%
  pivot_wider_spec(names_from = variable, values_from = c(estimate, moe)) %&gt;%
  mutate(.name = paste0(variable, ifelse(.value == &quot;moe&quot;, &quot;_moe&quot;, &quot;&quot;)))
#&gt; # A tibble: 4 x 3
#&gt;   .name      .value   variable
#&gt;   &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   
#&gt; 1 income     estimate income  
#&gt; 2 rent       estimate rent    
#&gt; 3 income_moe moe      income  
#&gt; 4 rent_moe   moe      rent</code></pre>
<a href="#fnref7" class="footnote-back">↩︎</a></li>
</ol>
</div>
